<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>INFO4310-HW4</title>
    <script src="https://d3js.org/d3.v6.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/d3-sankey@0.12.3/dist/d3-sankey.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Merriweather:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            font-family: 'Merriweather', serif;
            background-color: #f9fcf0;
            display: flex;
            justify-items: center;
            flex-direction: column;
            align-items: center;
        }

        #container{
            display: flex;
        }

        #sankey-container {
            margin-top: 10px;
            width: 100%;
            display: flex;
            justify-content: center;
        }

        #sankey {
            display: block;
            margin-left: auto;
            margin-right: auto;
        }

        .node rect {
            fill-opacity: 0.9;
            shape-rendering: crispEdges;
        }

        .node text {
            pointer-events: none;
            font-size: 12px;
        }

        .link {
            fill: none;
            stroke-opacity: 0.4;
            cursor: pointer;
        }

        .link:hover {
            stroke-opacity: 0.7;
        }

        .link.highlight {
            stroke-opacity: 0.7;
        }

        .link.dimmed {
            stroke-opacity: 0.1;
        }

        .node rect.dimmed {
            fill-opacity: 0.2;
        }

        .node rect.highlight {
            fill-opacity: 1;
        }

        #node-tooltip, #link-tooltip {
            background: #fff9e6;
            border: 2px solid #ffd700;
            border-radius: 6px;
            padding: 10px;
            font-family: 'Merriweather', serif;
            box-shadow: 0 3px 10px rgba(0,0,0,0.15);
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s ease;
            min-width: 160px;
            position: absolute;
            font-size: 13px;
        }

        #node-tooltip.show, #link-tooltip.show {
            opacity: 1;
        }

        #node-tooltip em, #link-tooltip em {
            color: #2a7a3b;
            font-style: normal;
            font-weight: 700;
        }

        .column-title {
            font-size: 14px;
            font-weight: bold;
            fill: #333;
            text-anchor: middle;
        }

        .info-icon {
            cursor: help;
            font-size: 12px;
            fill: #666;
        }

        .info-tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 6px 12px;
            border-radius: 4px;
            font-size: 12px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
        }

        .info-tooltip.show {
            opacity: 1;
        }

        .link, .node rect {
            transition: all 0.2s ease;
        }

        #main-title {
            text-align: center;
            font-size: 24px;
            color: #2a7a3b;
            margin: 20px 0;
            font-weight: 700;
        }

        #histograms-container {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 20px 0 30px 0;
        }

        .histogram .bar {
            fill: #059669;
            transition: all 0.2s ease;
        }

        .histogram .axis path,
        .histogram .axis line {
            stroke: #666;
        }

        .histogram .axis text {
            fill: #666;
            font-size: 11px;
        }

        .subtitle{
            color:#2a7a3b;
            font-weight: bold;
            margin: 0;
            font-size: 13px;
        }

        .no-data-label {
            font-size: 14px;
        }

        .x-axis-label, .y-axis-label {
            font-size: 11px;
        }

        .column-title {
            font-size: 14px;
            font-weight: bold;
            fill: #2a7a3b;
            text-anchor: middle;
        }

        a{
            color: lightgray
        }
    </style>
</head>

<body>
    <h1 id="main-title">Let's learn about 2000+ palm tree species!</h1>
    <div style="display: flex; flex-direction: row; width:900px;">
        <p class="subtitle" style="padding-left: 10px;">Subfamily</p>
        <p class="subtitle" style="padding-left: 130px;">Growth Habit <a href="#info_habit">i</a></p>
        <p class="subtitle" style="padding-left: 115px;">Growth Form</p>
        <p class="subtitle" style="padding-left: 125px;">Armature</p>
        <p class="subtitle" style="padding-left: 140px;">Stem Type</p>
    </div>
    <div id="container">
        <div id="sankey-container">
            <svg id="sankey" width="900" height="350"></svg>
        </div>
    </div>

    <div id="histograms-container">
        <svg id="height-histogram" class="histogram" width="450" height="250"></svg>
        <svg id="diameter-histogram" class="histogram" width="450" height="250"></svg>
    </div>

    <p id="info_habit">Growth habit: Climbing palms grow by attaching to supports; non-climbing palms stand upright on their own.</p>

    <div id="node-tooltip"></div>
    <div id="link-tooltip"></div>

    <script>
        const svg = d3.select("#sankey");
        const width = +svg.attr("width");
        const height = +svg.attr("height");
        const nodeTooltip = d3.select("#node-tooltip");
        const linkTooltip = d3.select("#link-tooltip");
        const sankeyLayout = d3.sankey()
            .nodeWidth(90)
            .nodePadding(20)
            .extent([[1, 1], [width - 1, height - 6]]);
        const color = d3.scaleOrdinal(d3.schemeSet3);

        let fullData = [];
        let nodeTimeout, linkTimeout;
        const tooltipDelay = 200;

        const histogramMargins = { top: 25, right: 20, bottom: 40, left: 45 };
        const histogramWidth = 450 - histogramMargins.left - histogramMargins.right;
        const histogramHeight = 250 - histogramMargins.top - histogramMargins.bottom;

        function prepareHistograms() {
            // Height histogram setup
            const heightSvg = d3.select("#height-histogram")
                .attr("width", histogramWidth + histogramMargins.left + histogramMargins.right)
                .attr("height", histogramHeight + histogramMargins.top + histogramMargins.bottom)
                .append("g")
                    .attr("transform", `translate(${histogramMargins.left},${histogramMargins.top})`);

            heightSvg.append("text")
                .attr("class", "column-title")
                .attr("x", histogramWidth / 2)
                .attr("y", -10)
                .text("Max. Stem Height (m)");

            // Diameter histogram setup
            const diameterSvg = d3.select("#diameter-histogram")
                .attr("width", histogramWidth + histogramMargins.left + histogramMargins.right)
                .attr("height", histogramHeight + histogramMargins.top + histogramMargins.bottom)
                .append("g")
                    .attr("transform", `translate(${histogramMargins.left},${histogramMargins.top})`);

            diameterSvg.append("text")
                .attr("class", "column-title")
                .attr("x", histogramWidth / 2)
                .attr("y", -10)
                .text("Max. Stem Diameter (cm)");
        }

        function updateHistograms(data, context) {
            updateHistogram(data, 'max_stem_height_m', '#height-histogram', context);
            updateHistogram(data, 'max_stem_dia_cm', '#diameter-histogram', context);
        }

        // Helper for mapping labels back to values
        function getRawValue(field, displayValue) {
            const mappings = {
                'stem_armed': { 'armed stem': 'armed', 'non-armed stem': 'non-armed' },
                'stem_solitary': { 'solitary stem': 'solitary', 'cluster stems': 'non-solitary' }
            };
            return mappings[field]?.[displayValue] || displayValue;
        }   

        function updateHistogram(data, field, selector, context) {
            const svg = d3.select(selector);
            const g = svg.select("g");
            const validData = data.filter(d => d[field] != null);
            const values = validData.map(d => +d[field])

            // Clear existing elements
            g.selectAll(".bar, .no-data-label").remove();

            // Update title based on context
            const title = g.select(".column-title")
                .text(getHistogramTitle(field, context));

            // Clear if no data
            if (values.length === 0) {
                console.log("I am here")
                g.append("text")
                    .attr("class", "no-data-label")
                    .attr("x", histogramWidth/2)
                    .attr("y", histogramHeight/2)
                    .attr("text-anchor", "middle")
                    .style("fill", "#666")
                    .style("font-style", "italic")
                    .text("No Data Available");
                return;
            }

            const x = d3.scaleLinear()
                .domain([d3.min(values), d3.max(values)])
                .range([0, histogramWidth]);

            // Update X axis
            const xAxis = d3.axisBottom(x);
            let xAxisGroup = g.select(".x-axis");
            if (!xAxisGroup.empty()) {
                xAxisGroup.call(xAxis);
            } else {
                g.append("g")
                    .attr("class", "x-axis")
                    .attr("transform", `translate(0,${histogramHeight})`)
                    .call(xAxis);
            }

            var histogram = d3.histogram()
                .domain(x.domain())
                .thresholds(x.ticks(40));
            
            var bins = histogram(values);

            const maxFrequency = d3.max(bins, d => d.length);
            const y = d3.scaleLinear()
                .domain([0, maxFrequency])
                .range([histogramHeight, 0]);

            const yAxis = d3.axisLeft(y)
                .ticks(d3.min([5, maxFrequency]))
                .tickFormat(d3.format("d"));
            let yAxisGroup = g.select(".y-axis");
            if (!yAxisGroup.empty()) {
                yAxisGroup.call(yAxis);
            } else {
                g.append("g")
                    .attr("class", "y-axis")
                    .call(yAxis);
            }

            // Add axis title
            if (g.select(".x-axis-label").empty()) {
                g.append("text")
                    .attr("class", "x-axis-label")
                    .attr("transform", `translate(${histogramWidth/2},${histogramHeight+35})`)
                    .style("text-anchor", "middle")
                    .text(field === 'max_stem_height_m' ? "Meters" : "Centimeters");
            }

            if (g.select(".y-axis-label").empty()) {
                g.append("text")
                    .attr("class", "y-axis-label")
                    .attr("transform", "rotate(-90)")
                    .attr("y", -histogramMargins.left + 10)
                    .attr("x", -histogramHeight/2)
                    .style("text-anchor", "middle")
                    .text("Frequency");
            }

            // Draw bins
            g.selectAll("rect")
                .data(bins)
                .enter()
                .append("rect")
                .attr("x", 1)
                .attr("transform", function(d) { return "translate(" + x(d.x0) + "," + y(d.length) + ")"; })
                .attr("width", function(d) { return d3.max([x(d.x1) - x(d.x0) - 1, 0]); })
                .attr("height", function(d) { return histogramHeight - y(d.length); })
                .style("fill", "#69b3a2")
                .style("opacity", 0.8)
                .attr("class", "bar")
        }

        function capitalizeFirst(str) {
            return str.charAt(0).toUpperCase() + str.slice(1);
        }

        // Helper function for dynamic titles
        function getHistogramTitle(field, context) {
            const baseTitle = field === 'max_stem_height_m' 
                ? "Max. Stem Height (m)" 
                : "Max. Stem Diameter (cm)";
    
            if (!context) return baseTitle;
    
            if (context.type === 'node') {
                return capitalizeFirst(`${context.value} trees: ${baseTitle}`);
            }
    
            if (context.type === 'link') {
                return capitalizeFirst(`${context.source} & ${context.target} trees: ${baseTitle}`);
            }
    
            return baseTitle;
        }

        function drawSankey() {
            svg.selectAll("*").remove();
            const nodesMap = new Map();
            const linksMap = new Map();

            function addLink(sourceRaw, targetRaw, sourceType, targetType) {
                if (!sourceRaw || !targetRaw) return;
                
                const mapValues = (type, value) => {
                    if (type === 'stem_armed') return value === 'armed' ? 'armed stem' : 'non-armed stem';
                    if (type === 'stem_solitary') return value === 'solitary' ? 'solitary stem' : 'cluster stems';
                    return value;
                };

                const sourceID = `${sourceType}: ${mapValues(sourceType, sourceRaw)}`;
                const targetID = `${targetType}: ${mapValues(targetType, targetRaw)}`;
                nodesMap.set(sourceID, mapValues(sourceType, sourceRaw));
                nodesMap.set(targetID, mapValues(targetType, targetRaw));
                const key = `${sourceID}->${targetID}`;
                linksMap.set(key, (linksMap.get(key) || 0) + 1);
            }

            fullData.forEach(tree => {
                addLink(tree.palm_subfamily, tree.climbing, 'palm_subfamily', 'climbing');
                addLink(tree.climbing, tree.erect, 'climbing', 'erect');
                addLink(tree.erect, tree.stem_armed, 'erect', 'stem_armed');
                addLink(tree.stem_armed, tree.stem_solitary, 'stem_armed', 'stem_solitary');
            });

            const nodeList = Array.from(nodesMap.entries()).map(([id, displayName]) => ({ id, displayName }));
            const nodeIndex = new Map(nodeList.map((node, i) => [node.id, i]));

            const sankeyData = {
                nodes: nodeList,
                links: Array.from(linksMap.entries()).map(([key, value]) => {
                    const [sourceID, targetID] = key.split('->');
                    return {
                        source: nodeIndex.get(sourceID),
                        target: nodeIndex.get(targetID),
                        value
                    };
                })
            };

            sankeyLayout(sankeyData);

            const linkPaths = svg.append("g")
                .selectAll("path")
                .data(sankeyData.links)
                .enter().append("path")
                .attr("class", "link")
                .attr("d", d3.sankeyLinkHorizontal())
                .attr("stroke", d => color(d.source.displayName))
                .attr("stroke-width", d => Math.max(1, d.width))
                .on("mouseover", function(event, d) {
                    clearTimeout(linkTimeout);
                    linkTimeout = setTimeout(() => {
                        const connectedNodes = new Set([d.source, d.target]);
                        const connectedLinks = new Set([d]);
        
                        linkPaths.classed("highlight", l => connectedLinks.has(l))
                            .classed("dimmed", l => !connectedLinks.has(l));
                        svg.selectAll(".node rect")
                            .classed("highlight", n => connectedNodes.has(n))
                            .classed("dimmed", n => !connectedNodes.has(n));

                        const total = fullData.length;
                        const percentage = ((d.value / total) * 100).toFixed(1);
                        const sourceValue = d.source.displayName;
                        const targetValue = d.target.displayName;

                        linkTooltip
                            .style("left", `${event.pageX + 15}px`)
                            .style("top", `${event.pageY - 10}px`)
                            .html(`
                                <div style="color: #856404; font-weight: 700;">${percentage}%</div>
                                <div style="font-size: 0.9em;">${getLinkText(sourceValue, targetValue)}</div>
                            `)
                            .classed("show", true);

                            const sourceField = d.source.id.split(': ')[0];
                            const targetField = d.target.id.split(': ')[0];
                            const sourceDisplayValue = d.source.displayName;
                            const targetDisplayValue = d.target.displayName;

                            // Convert display values to raw values
                            const rawSourceValue = getRawValue(sourceField, sourceDisplayValue);
                            const rawTargetValue = getRawValue(targetField, targetDisplayValue);

                            const subset = fullData.filter(tree => 
                                tree[sourceField] === rawSourceValue && 
                                tree[targetField] === rawTargetValue
                            );
                            updateHistograms(subset, {
                                type: 'link',
                                source: sourceDisplayValue,
                                target: targetDisplayValue
                            });
                        }, tooltipDelay);
                    })
                    .on("mousemove", function(event) {
                        linkTooltip
                            .style("left", `${event.pageX + 15}px`)
                            .style("top", `${event.pageY - 10}px`);
                    })
                    .on("mouseout", function() {
                        clearTimeout(linkTimeout);
                        linkPaths.classed("highlight", false)
                            .classed("dimmed", false);
                        svg.selectAll(".node rect")
                            .classed("highlight", false)
                            .classed("dimmed", false);
                        linkTooltip.classed("show", false);
                        updateHistograms(fullData);
                    });

            const nodesGroup = svg.append("g")
                .selectAll("g")
                .data(sankeyData.nodes)
                .enter().append("g")
                .attr("class", "node")
                .attr("transform", d => `translate(${d.x0},${d.y0})`);

            nodesGroup.append("rect")
                .attr("height", d => d.y1 - d.y0)
                .attr("width", d => d.x1 - d.x0)
                .attr("fill", d => color(d.displayName))
                .on("mouseover", function(event, d) {
                    clearTimeout(nodeTimeout);
                    nodeTimeout = setTimeout(() => {
                        const [field, value] = d.id.split(': ');
                        const count = fullData.filter(tree => {
                        const treeValue = getMappedValue(field, tree[field]);
                            return treeValue === value;
                        }).length;
                        const total = fullData.length;
                        const percent = ((count / total) * 100).toFixed(1);

                        // Collect all related nodes and links
                        const relatedNodes = new Set([d]);
                        const relatedLinks = new Set();

                        function traverseUp(node) {
                            node.targetLinks.forEach(link => {
                            if (!relatedLinks.has(link)) {
                                relatedLinks.add(link);
                                const sourceNode = link.source;
                                if (!relatedNodes.has(sourceNode)) {
                                    relatedNodes.add(sourceNode);
                                    traverseUp(sourceNode);
                                }
                            }
                            });
                        }

                        function traverseDown(node) {
                            node.sourceLinks.forEach(link => {
                            if (!relatedLinks.has(link)) {
                                relatedLinks.add(link);
                                const targetNode = link.target;
                                if (!relatedNodes.has(targetNode)) {
                                    relatedNodes.add(targetNode);
                                    traverseDown(targetNode);
                                }
                            }
                            });
                        }

                    traverseUp(d);
                    traverseDown(d);

                    // Highlight related elements
                    linkPaths.classed("highlight", l => relatedLinks.has(l))
                        .classed("dimmed", l => !relatedLinks.has(l));
                    svg.selectAll(".node rect")
                        .classed("highlight", n => relatedNodes.has(n))
                        .classed("dimmed", n => !relatedNodes.has(n));

                    nodeTooltip
                        .style("left", `${event.pageX + 15}px`)
                        .style("top", `${event.pageY - 10}px`)
                        .html(`
                            <div style="color: #856404; font-weight: 700;">${percent}%</div>
                            <div style="font-size: 0.9em;">${getNodeText(field, value)}</div>
                        `)
                        .classed("show", true);

                    const rawValue = getRawValue(field, value);
                    const subset = fullData.filter(tree => tree[field] === rawValue);
                    updateHistograms(subset, { 
                        type: 'node',
                        value: value,
                        field: field
                    });
                }, tooltipDelay);
            })
            .on("mousemove", function(event) {
                nodeTooltip
                    .style("left", `${event.pageX + 15}px`)
                    .style("top", `${event.pageY - 10}px`);
            })
            .on("mouseout", function() {
                clearTimeout(nodeTimeout);
                linkPaths.classed("highlight", false)
                    .classed("dimmed", false);
                svg.selectAll(".node rect")
                    .classed("highlight", false)
                    .classed("dimmed", false);
                nodeTooltip.classed("show", false);
                updateHistograms(fullData);
            });

            nodesGroup.append("text")
                .attr("x", 6)
                .attr("y", d => (d.y1 - d.y0) / 2)
                .attr("dy", "0.35em")
                .attr("text-anchor", "start")
                .each(function(d) {
                    const text = d3.select(this);
                    const label = d.displayName === "non-armed stem"
                        ? ["non-armed", "stem"]
                        : [d.displayName];

            label.forEach((line, i) => {
                text.append("tspan")
                    .attr("x", 6)
                    .attr("dy", i === 0 ? -2 : "1.2em")
                    .text(line);
             });
        });


        function getMappedValue(field, value) {
            const mappings = {
                'stem_armed': {
                    'armed': 'armed stem',
                    'non-armed': 'non-armed stem'
                },
                'stem_solitary': {
                    'solitary': 'solitary stem',
                    'non-solitary': 'cluster stems'
                }
            };
            return mappings[field]?.[value] || value;
        }

            function getNodeText(field, value) {
                const verb = field.startsWith('stem') ? 'have' : 'are';
                return `of palm tree species ${verb} <em>${value}</em>.`;
            }

            function getLinkText(source, target) {
                const sourceVerb = source.includes('stem') ? 'have' : 'are';
                const targetVerb = target.includes('stem') ? 'have' : 'are';
                return `of species that ${sourceVerb} <em>${source}</em><br>also ${targetVerb} <em>${target}</em>.`;
            }
        }

        d3.json("palmtrees_cleaned.json").then(data => {
            fullData = data;
            prepareHistograms();
            updateHistograms(fullData);
            drawSankey();
        });
    </script>
</body>
</html>