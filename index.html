<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>INFO4310-HW4</title>
    <script src="https://d3js.org/d3.v6.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/d3-sankey@0.12.3/dist/d3-sankey.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Merriweather:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            font-family: 'Merriweather', serif;
            background-color: #f9fcf0;
        }

        #container{
            display: flex;
        }

        #sankey-container {
            margin-top: 10px;
            width: 100%;
            display: flex;
            justify-content: center;
        }

        #sankey {
            display: block;
            margin-left: auto;
            margin-right: auto;
        }

        .node rect {
            fill-opacity: 0.9;
            shape-rendering: crispEdges;
        }

        .node text {
            pointer-events: none;
            font-size: 12px;
        }

        .link {
            fill: none;
            stroke-opacity: 0.4;
            cursor: pointer;
        }

        .link:hover {
            stroke-opacity: 0.7;
        }

        .link.highlight {
            stroke-opacity: 0.8;
        }

        .link.dimmed {
            stroke-opacity: 0.1;
        }

        .node rect.dimmed {
            fill-opacity: 0.2;
        }

        .node rect.highlight {
            fill-opacity: 1;
        }

        #node-tooltip, #link-tooltip {
            background: #fff9e6;
            border: 2px solid #ffd700;
            border-radius: 6px;
            padding: 12px;
            font-family: 'Merriweather', serif;
            box-shadow: 0 3px 10px rgba(0,0,0,0.15);
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s ease;
            min-width: 160px;
            position: absolute;
        }

        #node-tooltip.show, #link-tooltip.show {
            opacity: 1;
        }

        #node-tooltip em, #link-tooltip em {
            color: #2a7a3b;
            font-style: normal;
            font-weight: 700;
        }

        .column-title {
            font-size: 14px;
            font-weight: bold;
            fill: #333;
            text-anchor: middle;
        }

        .info-icon {
            cursor: help;
            font-size: 12px;
            fill: #666;
        }

        .info-tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 6px 12px;
            border-radius: 4px;
            font-size: 12px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
        }

        .info-tooltip.show {
            opacity: 1;
        }

        .link, .node rect {
            transition: all 0.2s ease;
        }

        #main-title {
            text-align: center;
            font-size: 24px;
            color: #2a7a3b;
            margin: 20px 0;
            font-weight: 700;
        }

        #histograms-container {
    display: flex;
    justify-content: center;
    gap: 20px;
    margin: 20px 0;
}

.histogram .bar {
    fill: #2a7a3b;
    transition: all 0.3s ease;
}

.histogram .axis path,
.histogram .axis line {
    stroke: #666;
}

.histogram .axis text {
    fill: #333;
    font-size: 10px;
}
    </style>
</head>

<body>
    <h1 id="main-title">Let's learn about palm tree species!</h1>
    <div id="container">
        <div id="sankey-container">
            <svg id="sankey" width="900" height="400"></svg>
        </div>
    </div>

    <div id="histograms-container">
        <svg id="height-histogram" class="histogram" width="450" height="250"></svg>
        <svg id="diameter-histogram" class="histogram" width="450" height="250"></svg>
    </div>

    <div id="node-tooltip"></div>
    <div id="link-tooltip"></div>

    <script>
        const svg = d3.select("#sankey");
        const width = +svg.attr("width");
        const height = +svg.attr("height");
        const nodeTooltip = d3.select("#node-tooltip");
        const linkTooltip = d3.select("#link-tooltip");
        const sankeyLayout = d3.sankey()
            .nodeWidth(90)
            .nodePadding(20)
            .extent([[1, 1], [width - 1, height - 6]]);
        const color = d3.scaleOrdinal(d3.schemeSet3);
        const columnInfo = {
            'palm_subfamily': 'Botanical subfamily classification of palm trees',
            'climbing': 'Presence of climbing growth habit',
            'erect': 'Whether the palm grows upright',
            'stem_armed': 'Presence of defensive structures on stem',
            'stem_solitary': 'Growth pattern (single or clustered stems)'
        };

        let fullData = [];
        let nodeTimeout, linkTimeout;
        const tooltipDelay = 200;

        const histogramMargins = { top: 20, right: 20, bottom: 30, left: 40 };
const histogramWidth = 450 - histogramMargins.left - histogramMargins.right;
const histogramHeight = 250 - histogramMargins.top - histogramMargins.bottom;

function prepareHistograms() {
    // Height histogram setup
    const heightSvg = d3.select("#height-histogram")
        .attr("width", histogramWidth + histogramMargins.left + histogramMargins.right)
        .attr("height", histogramHeight + histogramMargins.top + histogramMargins.bottom)
        .append("g")
        .attr("transform", `translate(${histogramMargins.left},${histogramMargins.top})`);

    heightSvg.append("text")
        .attr("class", "column-title")
        .attr("x", histogramWidth / 2)
        .attr("y", -5)
        .text("Maximum Stem Height (m)");

    // Diameter histogram setup
    const diameterSvg = d3.select("#diameter-histogram")
        .attr("width", histogramWidth + histogramMargins.left + histogramMargins.right)
        .attr("height", histogramHeight + histogramMargins.top + histogramMargins.bottom)
        .append("g")
        .attr("transform", `translate(${histogramMargins.left},${histogramMargins.top})`);

    diameterSvg.append("text")
        .attr("class", "column-title")
        .attr("x", histogramWidth / 2)
        .attr("y", -5)
        .text("Maximum Stem Diameter (cm)");
}

function updateHistograms(data) {
    updateHistogram(data, 'max_stem_height_m', '#height-histogram');
    updateHistogram(data, 'max_stem_dia_cm', '#diameter-histogram');
}

function getRawValue(field, displayValue) {
    const mappings = {
        'stem_armed': { 'armed stem': 'armed', 'non-armed stem': 'non-armed' },
        'stem_solitary': { 'solitary stem': 'solitary', 'cluster stems': 'non-solitary' }
    };
    return mappings[field]?.[displayValue] || displayValue;
}

function updateHistogram(data, field, selector) {
    const svg = d3.select(selector);
    const g = svg.select("g");
    const validData = data.filter(d => d[field] != null);
    const values = validData.map(d => +d[field]);

    if (values.length === 0) {
        g.selectAll(".bar, .x-axis, .y-axis").remove();
        return;
    }

    const xDomain = [d3.min(values), d3.max(values)];
    const histogram = d3.histogram().domain(xDomain).thresholds(d3.thresholdScott(values));
    const bins = histogram(values);

    const xScale = d3.scaleLinear().domain(xDomain).range([0, histogramWidth]);
    const yScale = d3.scaleLinear().domain([0, d3.max(bins, d => d.length)]).range([histogramHeight, 0]);

    // Update bars
    const bars = g.selectAll(".bar").data(bins);
    bars.exit().remove();

    bars.enter().append("rect")
        .attr("class", "bar")
        .merge(bars)
        .transition().duration(300)
        .attr("x", d => xScale(d.x0))
        .attr("width", d => Math.max(0, xScale(d.x1) - xScale(d.x0) - 1))
        .attr("y", d => yScale(d.length))
        .attr("height", d => histogramHeight - yScale(d.length));

    // Update axes
    const xAxis = d3.axisBottom(xScale);
    const yAxis = d3.axisLeft(yScale);

    svg.select(".x-axis").remove();
    svg.select(".y-axis").remove();

    g.append("g")
        .attr("class", "x-axis")
        .attr("transform", `translate(0, ${histogramHeight})`)
        .call(xAxis);

    g.append("g")
        .attr("class", "y-axis")
        .call(yAxis);
}

        d3.json("palmtrees_cleaned.json").then(data => {
            fullData = data;
            prepareHistograms();
            updateHistograms(fullData);
            drawSankey();
        });

        function drawSankey() {
            svg.selectAll("*").remove();
            const nodesMap = new Map();
            const linksMap = new Map();

            function addLink(sourceRaw, targetRaw, sourceType, targetType) {
                if (!sourceRaw || !targetRaw) return;
                
                const mapValues = (type, value) => {
                    if (type === 'stem_armed') return value === 'armed' ? 'armed stem' : 'non-armed stem';
                    if (type === 'stem_solitary') return value === 'solitary' ? 'solitary stem' : 'cluster stems';
                    return value;
                };

                const sourceID = `${sourceType}: ${mapValues(sourceType, sourceRaw)}`;
                const targetID = `${targetType}: ${mapValues(targetType, targetRaw)}`;
                nodesMap.set(sourceID, mapValues(sourceType, sourceRaw));
                nodesMap.set(targetID, mapValues(targetType, targetRaw));
                const key = `${sourceID}->${targetID}`;
                linksMap.set(key, (linksMap.get(key) || 0) + 1);
            }

            fullData.forEach(tree => {
                addLink(tree.palm_subfamily, tree.climbing, 'palm_subfamily', 'climbing');
                addLink(tree.climbing, tree.erect, 'climbing', 'erect');
                addLink(tree.erect, tree.stem_armed, 'erect', 'stem_armed');
                addLink(tree.stem_armed, tree.stem_solitary, 'stem_armed', 'stem_solitary');
            });

            const nodeList = Array.from(nodesMap.entries()).map(([id, displayName]) => ({ id, displayName }));
            const nodeIndex = new Map(nodeList.map((node, i) => [node.id, i]));

            const sankeyData = {
                nodes: nodeList,
                links: Array.from(linksMap.entries()).map(([key, value]) => {
                    const [sourceID, targetID] = key.split('->');
                    return {
                        source: nodeIndex.get(sourceID),
                        target: nodeIndex.get(targetID),
                        value
                    };
                })
            };

            sankeyLayout(sankeyData);

            const linkPaths = svg.append("g")
                .selectAll("path")
                .data(sankeyData.links)
                .enter().append("path")
                .attr("class", "link")
                .attr("d", d3.sankeyLinkHorizontal())
                .attr("stroke", d => color(d.source.displayName))
                .attr("stroke-width", d => Math.max(1, d.width))
                .on("mouseover", function(event, d) {
                clearTimeout(linkTimeout);
                linkTimeout = setTimeout(() => {
                    const connectedNodes = new Set([d.source, d.target]);
                    const connectedLinks = new Set([d]);
        
                linkPaths.classed("highlight", l => connectedLinks.has(l))
                    .classed("dimmed", l => !connectedLinks.has(l));
                svg.selectAll(".node rect")
                    .classed("highlight", n => connectedNodes.has(n))
                    .classed("dimmed", n => !connectedNodes.has(n));

                        const total = fullData.length;
                        const percentage = ((d.value / total) * 100).toFixed(1);
                        const sourceValue = d.source.displayName;
                        const targetValue = d.target.displayName;

                        linkTooltip
                            .style("left", `${event.pageX + 15}px`)
                            .style("top", `${event.pageY - 10}px`)
                            .html(`
                                <div style="color: #856404; font-weight: 700;">${percentage}%</div>
                                <div style="font-size: 0.9em;">${getLinkText(sourceValue, targetValue)}</div>
                            `)
                            .classed("show", true);

                            const sourceField = d.source.id.split(': ')[0];
        const targetField = d.target.id.split(': ')[0];
        const sourceDisplayValue = d.source.displayName;
        const targetDisplayValue = d.target.displayName;

        // Convert display values to raw values
        const rawSourceValue = getRawValue(sourceField, sourceDisplayValue);
        const rawTargetValue = getRawValue(targetField, targetDisplayValue);

        const subset = fullData.filter(tree => 
            tree[sourceField] === rawSourceValue && 
            tree[targetField] === rawTargetValue
        );
        updateHistograms(subset);
                    }, tooltipDelay);
                })
                .on("mousemove", function(event) {
                    linkTooltip
                        .style("left", `${event.pageX + 15}px`)
                        .style("top", `${event.pageY - 10}px`);
                })
                .on("mouseout", function() {
                    clearTimeout(linkTimeout);
            linkPaths.classed("highlight", false)
                .classed("dimmed", false);
            svg.selectAll(".node rect")
                .classed("highlight", false)
                .classed("dimmed", false);
            linkTooltip.classed("show", false);
            updateHistograms(fullData);
                });

            const nodesGroup = svg.append("g")
                .selectAll("g")
                .data(sankeyData.nodes)
                .enter().append("g")
                .attr("class", "node")
                .attr("transform", d => `translate(${d.x0},${d.y0})`);

            nodesGroup.append("rect")
                .attr("height", d => d.y1 - d.y0)
                .attr("width", d => d.x1 - d.x0)
                .attr("fill", d => color(d.displayName))
                .on("mouseover", function(event, d) {
            clearTimeout(nodeTimeout);
            nodeTimeout = setTimeout(() => {
                const [field, value] = d.id.split(': ');
                const count = fullData.filter(tree => {
                    const treeValue = getMappedValue(field, tree[field]);
                    return treeValue === value;
                }).length;
                const total = fullData.length;
                const percent = ((count / total) * 100).toFixed(1);

                // Collect all related nodes and links
                const relatedNodes = new Set([d]);
                const relatedLinks = new Set();

                function traverseUp(node) {
                    node.targetLinks.forEach(link => {
                        if (!relatedLinks.has(link)) {
                            relatedLinks.add(link);
                            const sourceNode = link.source;
                            if (!relatedNodes.has(sourceNode)) {
                                relatedNodes.add(sourceNode);
                                traverseUp(sourceNode);
                            }
                        }
                    });
                }

                function traverseDown(node) {
                    node.sourceLinks.forEach(link => {
                        if (!relatedLinks.has(link)) {
                            relatedLinks.add(link);
                            const targetNode = link.target;
                            if (!relatedNodes.has(targetNode)) {
                                relatedNodes.add(targetNode);
                                traverseDown(targetNode);
                            }
                        }
                    });
                }

                traverseUp(d);
                traverseDown(d);

                // Highlight related elements
                linkPaths.classed("highlight", l => relatedLinks.has(l))
                    .classed("dimmed", l => !relatedLinks.has(l));
                svg.selectAll(".node rect")
                    .classed("highlight", n => relatedNodes.has(n))
                    .classed("dimmed", n => !relatedNodes.has(n));

                nodeTooltip
                    .style("left", `${event.pageX + 15}px`)
                    .style("top", `${event.pageY - 10}px`)
                    .html(`
                        <div style="color: #856404; font-weight: 700;">${percent}%</div>
                        <div style="font-size: 0.9em;">${getNodeText(field, value)}</div>
                    `)
                    .classed("show", true);

const rawValue = getRawValue(field, value);
const subset = fullData.filter(tree => tree[field] === rawValue);
updateHistograms(subset);
            }, tooltipDelay);
        })
                .on("mousemove", function(event) {
                    nodeTooltip
                        .style("left", `${event.pageX + 15}px`)
                        .style("top", `${event.pageY - 10}px`);
                })
                .on("mouseout", function() {
                    clearTimeout(nodeTimeout);
            linkPaths.classed("highlight", false)
                .classed("dimmed", false);
            svg.selectAll(".node rect")
                .classed("highlight", false)
                .classed("dimmed", false);
            nodeTooltip.classed("show", false);
            updateHistograms(fullData);
                });

                nodesGroup.append("text")
    .attr("x", 6)
    .attr("y", d => (d.y1 - d.y0) / 2)
    .attr("dy", "0.35em")
    .attr("text-anchor", "start")
    .each(function(d) {
        const text = d3.select(this);
        const label = d.displayName === "non-armed stem"
            ? ["non-armed", "stem"]
            : [d.displayName];

        label.forEach((line, i) => {
            text.append("tspan")
                .attr("x", 6)
                .attr("dy", i === 0 ? -2 : "1.2em")
                .text(line);
        });
    });


            function getMappedValue(field, value) {
                const mappings = {
                    'stem_armed': {
                        'armed': 'armed stem',
                        'non-armed': 'non-armed stem'
                    },
                    'stem_solitary': {
                        'solitary': 'solitary stem',
                        'non-solitary': 'cluster stems'
                    }
                };
                return mappings[field]?.[value] || value;
            }

            function getNodeText(field, value) {
                const verb = field.startsWith('stem') ? 'have' : 'are';
                return `of palm tree species ${verb} <em>${value}</em>.`;
            }

            function getLinkText(source, target) {
                const sourceVerb = source.includes('stem') ? 'have' : 'are';
                const targetVerb = target.includes('stem') ? 'have' : 'are';
                return `of species that ${sourceVerb} <em>${source}</em><br>also ${targetVerb} <em>${target}</em>.`;
            }
        }
    </script>
</body>
</html>